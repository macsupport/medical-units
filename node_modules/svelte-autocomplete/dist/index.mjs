function noop() {}

function assign(tar, src) {
	for (var k in src) tar[k] = src[k];
	return tar;
}

function assignTrue(tar, src) {
	for (var k in src) tar[k] = 1;
	return tar;
}

function append(target, node) {
	target.appendChild(node);
}

function insert(target, node, anchor) {
	target.insertBefore(node, anchor);
}

function detachNode(node) {
	node.parentNode.removeChild(node);
}

function reinsertBetween(before, after, target) {
	while (before.nextSibling && before.nextSibling !== after) {
		target.appendChild(before.parentNode.removeChild(before.nextSibling));
	}
}

function destroyEach(iterations, detach) {
	for (var i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detach);
	}
}

function createElement(name) {
	return document.createElement(name);
}

function createText(data) {
	return document.createTextNode(data);
}

function createComment() {
	return document.createComment('');
}

function addListener(node, event, handler, options) {
	node.addEventListener(event, handler, options);
}

function removeListener(node, event, handler, options) {
	node.removeEventListener(event, handler, options);
}

function setAttribute(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else node.setAttribute(attribute, value);
}

function blankObject() {
	return Object.create(null);
}

function destroy(detach) {
	this.destroy = noop;
	this.fire('destroy');
	this.set = noop;

	this._fragment.d(detach !== false);
	this._fragment = null;
	this._state = {};
}

function _differs(a, b) {
	return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}

function fire(eventName, data) {
	var handlers =
		eventName in this._handlers && this._handlers[eventName].slice();
	if (!handlers) return;

	for (var i = 0; i < handlers.length; i += 1) {
		var handler = handlers[i];

		if (!handler.__calling) {
			try {
				handler.__calling = true;
				handler.call(this, data);
			} finally {
				handler.__calling = false;
			}
		}
	}
}

function flush(component) {
	component._lock = true;
	callAll(component._beforecreate);
	callAll(component._oncreate);
	callAll(component._aftercreate);
	component._lock = false;
}

function get() {
	return this._state;
}

function init(component, options) {
	component._handlers = blankObject();
	component._slots = blankObject();
	component._bind = options._bind;
	component._staged = {};

	component.options = options;
	component.root = options.root || component;
	component.store = options.store || component.root.store;

	if (!options.root) {
		component._beforecreate = [];
		component._oncreate = [];
		component._aftercreate = [];
	}
}

function on(eventName, handler) {
	var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
	handlers.push(handler);

	return {
		cancel: function() {
			var index = handlers.indexOf(handler);
			if (~index) handlers.splice(index, 1);
		}
	};
}

function set(newState) {
	this._set(assign({}, newState));
	if (this.root._lock) return;
	flush(this.root);
}

function _set(newState) {
	var oldState = this._state,
		changed = {},
		dirty = false;

	newState = assign(this._staged, newState);
	this._staged = {};

	for (var key in newState) {
		if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
	}
	if (!dirty) return;

	this._state = assign(assign({}, oldState), newState);
	this._recompute(changed, this._state);
	if (this._bind) this._bind(changed, this._state);

	if (this._fragment) {
		this.fire("state", { changed: changed, current: this._state, previous: oldState });
		this._fragment.p(changed, this._state);
		this.fire("update", { changed: changed, current: this._state, previous: oldState });
	}
}

function _stage(newState) {
	assign(this._staged, newState);
}

function callAll(fns) {
	while (fns && fns.length) fns.shift()();
}

function _mount(target, anchor) {
	this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
}

var proto = {
	destroy,
	get,
	fire,
	on,
	set,
	_recompute: noop,
	_set,
	_stage,
	_mount,
	_differs
};

/* src/index.html generated by Svelte v2.16.0 */

const regExpEscape = (s) => {
  return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&")
};

function data() {
  return {
    name: '',
    value: '',
    placeholder: '',
    required: false,
    disabled: false,

    // autocomplete props
    items: [],
    isOpen: false,
    results: [],
    search: '',
    isLoading: false,
    arrowCounter: 0,

    // options
    class: '',
    isAsync: false,
    minChar: 2,
    maxItems: 10,
    fromStart: true, // Default type ahead
  }
}
var methods = {
  async onChange (event) {
    const { isAsync, search, minChar } = this.get();
    this.fire('input', search);

    // Is the data given by an outside ajax request?
    if (this.get().isAsync) {
      this.set({ isLoading: true });
    } else if (search.length >= Number(minChar)) {
      this.filterResults();
      this.set({ isOpen: true });
    }
  },
  filterResults () {
    const { items, search, fromStart, maxItems } = this.get();
    const results = items.filter(item => {
      if (typeof item !== 'string') {
        item = item.key || ''; // Silent fail
      }
      return fromStart ? item.toUpperCase().startsWith(search.toUpperCase())
                       : item.toUpperCase().includes(search.toUpperCase())
    })
    .map(item => {
      const text = typeof item !== 'string' ? item.key : item;
      return {
        key: text,
        value: item.value || item,
        label: search.trim() === '' ? text : text.replace(RegExp(regExpEscape(search.trim()), 'i'), "<span>$&</span>")
      }
    });
    this.set({ results });

    const height = results.length > maxItems ? maxItems : results.length;
    this.refs.list.style.height = `${height * 2.25}rem`;
  },
  onKeyDown (event) {
    let { arrowCounter, results } = this.get();

    if (event.keyCode === 40 && arrowCounter < results.length) {
      // ArrowDown
      this.set({ arrowCounter: arrowCounter + 1 });
    } else if (event.keyCode === 38 && arrowCounter > 0) {
      // ArrowUp
      this.set({ arrowCounter: arrowCounter - 1 });
    } else if (event.keyCode === 13) {
      // Enter
      event.preventDefault();
      if (arrowCounter === -1) {
        arrowCounter = 0; // Default select first item of list
      }
      this.close(arrowCounter);
    } else if (event.keyCode === 27) {
      // Escape
      event.preventDefault();
      this.close();
    }
  },
  close (index = -1) {
    this.set({ isOpen: false, arrowCounter: -1 });
    this.refs.input.blur();
    if (index > -1) {
      const { results } = this.get();
      const { key, value } = results[index];
      this.set({ value, search: key });
      this.fire('change', value);
    } else if (!this.get().value) {
      this.set({ search: '' });
    }
  }
};

function onupdate({ changed, current }) {
  if (this.get().isAsync && changed.items && current.items.length) {
    this.set({
      items: current.items,
      isLoading: false,
      isOpen: true
    });
    this.filterResults();
  }
}
function add_css() {
	var style = createElement("style");
	style.id = 'svelte-1yo2r3-style';
	style.textContent = ".svelte-1yo2r3{box-sizing:border-box}input.svelte-1yo2r3{height:2rem;font-size:1rem;padding:0.25rem 0.5rem}.autocomplete.svelte-1yo2r3{position:relative}.hide-results.svelte-1yo2r3{display:none}.autocomplete-results.svelte-1yo2r3{padding:0;margin:0;border:1px solid #dbdbdb;height:6rem;overflow:auto;width:100%;background-color:white;box-shadow:2px 2px 24px rgba(0, 0, 0, 0.1);position:absolute;z-index:100}.autocomplete-result.svelte-1yo2r3{color:#7a7a7a;list-style:none;text-align:left;height:2rem;padding:0.25rem 0.5rem;cursor:pointer}.autocomplete-result.svelte-1yo2r3>span{background-color:none;color:#242424;font-weight:bold}.autocomplete-result.is-active.svelte-1yo2r3,.autocomplete-result.svelte-1yo2r3:hover{background-color:#dbdbdb}";
	append(document.head, style);
}

function click_handler(event) {
	const { component, ctx } = this._svelte;

	component.close(ctx.i);
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.result = list[i];
	child_ctx.i = i;
	return child_ctx;
}

function create_main_fragment(component, ctx) {
	var div, input, input_updating = false, input_value_value, text0, ul, ul_class_value, text1;

	function onwindowclick(event) {
		component.close();	}
	window.addEventListener("click", onwindowclick);

	function input_input_handler() {
		input_updating = true;
		component.set({ search: input.value });
		input_updating = false;
	}

	function input_handler(event) {
		component.onChange(event);
	}

	function focus_handler(event) {
		component.fire('focus', event);
	}

	function blur_handler(event) {
		component.fire('blur', event);
	}

	function keydown_handler(event) {
		component.onKeyDown(event);
	}

	var each_value = ctx.results;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
	}

	var if_block = (ctx.isLoading) && create_if_block(component, ctx);

	function click_handler_1(event) {
		event.stopPropagation();
	}

	return {
		c() {
			div = createElement("div");
			input = createElement("input");
			text0 = createText("\n  ");
			ul = createElement("ul");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			text1 = createText("\n");
			if (if_block) if_block.c();
			addListener(input, "input", input_input_handler);
			addListener(input, "input", input_handler);
			addListener(input, "focus", focus_handler);
			addListener(input, "blur", blur_handler);
			addListener(input, "keydown", keydown_handler);
			setAttribute(input, "type", "text");
			input.className = "" + ctx.class + " svelte-1yo2r3";
			input.name = ctx.name;
			input.placeholder = ctx.placeholder;
			input.required = ctx.required;
			input.disabled = ctx.disabled;
			input.value = input_value_value = ctx.value || '';
			input.autocomplete = ctx.name;
			ul.className = ul_class_value = "autocomplete-results" + (!ctx.isOpen ? ' hide-results' : '') + " svelte-1yo2r3";
			addListener(div, "click", click_handler_1);
			div.className = "autocomplete svelte-1yo2r3";
		},

		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			component.refs.input = input;

			input.value = ctx.search;

			append(div, text0);
			append(div, ul);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			component.refs.list = ul;
			append(div, text1);
			if (if_block) if_block.m(div, null);
		},

		p(changed, ctx) {
			if (!input_updating && changed.search) input.value = ctx.search;
			if (changed.class) {
				input.className = "" + ctx.class + " svelte-1yo2r3";
			}

			if (changed.name) {
				input.name = ctx.name;
			}

			if (changed.placeholder) {
				input.placeholder = ctx.placeholder;
			}

			if (changed.required) {
				input.required = ctx.required;
			}

			if (changed.disabled) {
				input.disabled = ctx.disabled;
			}

			if ((changed.value) && input_value_value !== (input_value_value = ctx.value || '')) {
				input.value = input_value_value;
			}

			if (changed.name) {
				input.autocomplete = ctx.name;
			}

			if (changed.arrowCounter || changed.results) {
				each_value = ctx.results;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(component, child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((changed.isOpen) && ul_class_value !== (ul_class_value = "autocomplete-results" + (!ctx.isOpen ? ' hide-results' : '') + " svelte-1yo2r3")) {
				ul.className = ul_class_value;
			}

			if (ctx.isLoading) {
				if (!if_block) {
					if_block = create_if_block(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d(detach) {
			window.removeEventListener("click", onwindowclick);

			if (detach) {
				detachNode(div);
			}

			removeListener(input, "input", input_input_handler);
			removeListener(input, "input", input_handler);
			removeListener(input, "focus", focus_handler);
			removeListener(input, "blur", blur_handler);
			removeListener(input, "keydown", keydown_handler);
			if (component.refs.input === input) component.refs.input = null;

			destroyEach(each_blocks, detach);

			if (component.refs.list === ul) component.refs.list = null;
			if (if_block) if_block.d();
			removeListener(div, "click", click_handler_1);
		}
	};
}

// (20:0) {#each results as result, i}
function create_each_block(component, ctx) {
	var li, raw_value = ctx.result.label, li_class_value;

	return {
		c() {
			li = createElement("li");
			li._svelte = { component, ctx };

			addListener(li, "click", click_handler);
			li.className = li_class_value = "autocomplete-result" + (ctx.i === ctx.arrowCounter ? ' is-active' : '') + " svelte-1yo2r3";
		},

		m(target, anchor) {
			insert(target, li, anchor);
			li.innerHTML = raw_value;
		},

		p(changed, _ctx) {
			ctx = _ctx;
			if ((changed.results) && raw_value !== (raw_value = ctx.result.label)) {
				li.innerHTML = raw_value;
			}

			li._svelte.ctx = ctx;
			if ((changed.arrowCounter) && li_class_value !== (li_class_value = "autocomplete-result" + (ctx.i === ctx.arrowCounter ? ' is-active' : '') + " svelte-1yo2r3")) {
				li.className = li_class_value;
			}
		},

		d(detach) {
			if (detach) {
				detachNode(li);
			}

			removeListener(li, "click", click_handler);
		}
	};
}

// (26:0) {#if isLoading}
function create_if_block(component, ctx) {
	var slot_content_default = component._slotted.default, slot_content_default_before, slot_content_default_after, p;

	return {
		c() {
			if (!slot_content_default) {
				p = createElement("p");
				p.textContent = "Loading data...";
			}
			if (!slot_content_default) {
				p.className = "fallback svelte-1yo2r3";
			}
		},

		m(target, anchor) {
			if (!slot_content_default) {
				insert(target, p, anchor);
			}

			else {
				insert(target, slot_content_default_before || (slot_content_default_before = createComment()), anchor);
				insert(target, slot_content_default, anchor);
				insert(target, slot_content_default_after || (slot_content_default_after = createComment()), anchor);
			}
		},

		d(detach) {
			if (!slot_content_default) {
				if (detach) {
					detachNode(p);
			}

			}

			else {
				reinsertBetween(slot_content_default_before, slot_content_default_after, slot_content_default);
				detachNode(slot_content_default_before);
				detachNode(slot_content_default_after);
			}
		}
	};
}

function Index(options) {
	init(this, options);
	this.refs = {};
	this._state = assign(data(), options.data);
	this._intro = true;
	this._handlers.update = [onupdate];

	this._slotted = options.slots || {};

	if (!document.getElementById("svelte-1yo2r3-style")) add_css();

	this._fragment = create_main_fragment(this, this._state);

	this.root._oncreate.push(() => {
		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
	});

	if (options.target) {
		this._fragment.c();
		this._mount(options.target, options.anchor);

		flush(this);
	}
}

assign(Index.prototype, proto);
assign(Index.prototype, methods);

export default Index;
